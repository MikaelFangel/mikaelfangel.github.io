[{"content":"Here I\u0026rsquo;ll post the code for my solutions to the 1st chapter of the book.\n1.1 1 let g n = n + 4 1.2 1 let h (x, y) = System.Math.Sqrt(x * x + y * y) 1.3 The function expression for g is of type int -\u0026gt; int and the function expression for h is (float * float) -\u0026gt; float\n1.4 The recusion formula for the following problem is:\n1 2 0 = 0 n = n + (n - 1) for n \u0026gt; 0 The code for the assignment:\n1 2 3 4 let rec f = function | 0 -\u0026gt; 0 | n -\u0026gt; n + f (n - 1) The evaluation for f 3 is as follows:\n1 2 3 4 5 6 7 8 9 10 11 ~\u0026gt; f 3 ~\u0026gt; 3 + f (n - 1) ~\u0026gt; 3 + f 2 ~\u0026gt; 3 + (2 + f(2 - 1)) ~\u0026gt; 3 + (2 + f 1) ~\u0026gt; 3 + (2 + (1 + f(1 - 1)) ~\u0026gt; 3 + (2 + (1 + f 0)) ~\u0026gt; 3 + (2 + (1 + 0)) ~\u0026gt; 3 + (2 + 1) ~\u0026gt; 3 + 3 ~\u0026gt; 6 1.5 The naive implementation of the solution to the problem would look like the code below. This solutions is however problematic because the recursion tree would expand exponentially. This due to the fact you call fib (n -1) + fib (n -2) and thus you do two recursive calls for each level (if you imangine it as a tree) of your fibonacci sequence.\n1 2 3 4 let rec fib = function | 0 -\u0026gt; 0 | 1 -\u0026gt; 1 | n -\u0026gt; fib (n - 1) + fib (n - 2) A better approach would be to utilize the concept of tail-recusion when solving the task, but this is unlikely the reader knows that at this point in the book. This would convert the recursive call into simple goto statements and thus avoid the exponetial stack growth as the previous solution. The new solution would the look something like this:\n1 2 3 4 5 6 let fib n = let rec inner_fib n a b = match n with | 0 -\u0026gt; a | _ -\u0026gt; inner_fib (n - 1) b (a + b) inner_fib n 0 1 The evaluation for fib 4 is as follows for the naive solution:\n1 2 3 4 5 6 7 8 9 10 11 ~\u0026gt; fib 4 ~\u0026gt; fib (4 - 1) + fib (4 - 2) ~\u0026gt; fib 3 + fib 2 ~\u0026gt; (fib (3 - 1) + fib (3 - 2)) + (fib (2 - 1) + fib (2 - 2)) ~\u0026gt; (fib 2 + fib 1) + (fib 1 + fib 0) ~\u0026gt; ((fib (2 - 1) + fib(2 - 2) + fib 1) + (1 + 0)) ~\u0026gt; ((fib 1 + fib 0) + 1) + (1 + 0)) ~\u0026gt; ((1 + 0) + 1) + (1 + 0)) ~\u0026gt; (1 + 1) + (1 + 0)) ~\u0026gt; 2 + 1 ~\u0026gt; 3 1.6 The recursion formula for the following problem is:\n1 2 (m, 0) = m (m, n) = m + (m, n - 1) The code for the solution:\n1 2 3 let rec sum = function | (m, 0) -\u0026gt; m | (m, n) -\u0026gt; m + sum (m, n - 1) 1.7 The type for the expressions is: (System.Math.PI, fact -1) = (float * int) fact(fact 4) = int power(System.Math.PI, fact 2) = float (power, fact) = (float -\u0026gt; int -\u0026gt; float) * (int -\u0026gt; int))\nBook by Michael R. Hansen and Hans Richel\nPhoto by Ilija Boshkov on Unsplash\n","date":"2024-05-04T00:00:00Z","image":"https://mikaelfangel.github.io/p/function-programming-chap1/cover_hu1164555520794942236.jpg","permalink":"https://mikaelfangel.github.io/p/function-programming-chap1/","title":"Solutions to Functional Programming Using F# Chap. 1"},{"content":"Recently I\u0026rsquo;ve written a review on a PR where I requested that we used the Obsidian icon from the source. However this icon is only available as an svg file with a transparent background. So I suggested that we used imagemagick to add the background to the image because we already used it in the derivation. This task is however not as trivial as it first might seem. The PR with the discussion can be found here.\nTo add the background to the image I came up with the following solution:\n1 2 3 4 5 6 7 8 # Create the shadowed image convert input.png \\( +clone -background \u0026#34;rgba(0,0,0,0.5)\u0026#34; -shadow 50x5+5+5 \\) +swap -background none -layers merge +repage shadowed_image.png # Create the rounded mask convert -size XxY xc:none -fill \u0026#34;#232129\u0026#34; -draw \u0026#34;roundrectangle 0,0,X,Y,35,35\u0026#34; mask.png # Overlay the rounded image with the shadow onto the colored background convert -gravity center mask.png shadowed_image.png -composite -compose SrcIn rounded.png In the solution X and Y denotes the size of the output image.\n","date":"2023-10-16T00:00:00Z","permalink":"https://mikaelfangel.github.io/p/imagemagick-icon/","title":"Add a background to the Obisidian icon using imagemagick"},{"content":"In the fast-paced world of software development, managing packages efficiently and ensuring seamless updates is crucial. This is where \u0026ldquo;flakehub.com,\u0026rdquo; brought to you by Determinate Systems, comes into play. In this post, we\u0026rsquo;ll dive into what FlakeHub is all about and how it can simplify your software management processes.\nWhat is FlakeHub? FlakeHub is a platform designed to facilitate the publication and management of software packages, commonly referred to as \u0026ldquo;flakes.\u0026rdquo; What sets FlakeHub apart is its ability to accommodate both public and unlisted flakes, making it a versatile solution for developers and organizations alike. By centralizing your flakes on FlakeHub, you gain the advantage of easy accessibility and searchability.\nSemantic Versioning Made Easy At the core of FlakeHub\u0026rsquo;s approach to package management is the use of Semantic Versioning, or SemVer. SemVer is a versioning scheme that allows developers to communicate changes and updates in a standardized way. With FlakeHub, all packages are managed using this scheme, providing users with a clear understanding of what to expect from packages and how updates may impact their systems. It is with this approach also very easy to define rules for how systems update their packages based on the versions alone.\nAutomate with GitHub Actions One of the standout features of FlakeHub is its integration with GitHub Actions. Determinate Systems has developed a GitHub Action that empowers you to effortlessly publish your flakes to the hub. This automation not only saves time but also ensures that your packages follow SemVer conventions. By automating the process, you can keep your packages up-to-date and well-organized with minimal effort.\nGitHub Action Generator To further simplify the integration of FlakeHub with your projects, Determinate Systems offers a GitHub Action generator. This tool is designed to streamline the process of adding the necessary workflow to your GitHub repository. With just a few clicks, you can configure the automatic publishing of your flakes, making it a breeze to manage your packages efficiently.\nGet Started with FlakeHub If you\u0026rsquo;re eager to explore FlakeHub and leverage its powerful features for your software projects, head over to their website at flakehub.com. There, you\u0026rsquo;ll find more detailed information, guides, and resources to help you get started.\nIn conclusion, FlakeHub, powered by Determinate Systems, is poised to revolutionize the way you manage and publish software packages. With its commitment to SemVer, automation through GitHub Actions, and user-friendly GitHub Action generator.\n","date":"2023-10-01T00:00:00Z","permalink":"https://mikaelfangel.github.io/p/flakehub-initial-thoughts/","title":"Flakehub Intial Thoughts"},{"content":"Motivation Nix Flakes introduce a new way of managing and deploying Nix packages and configurations. This post aims to provide an overview of what Nix Flakes are, how they differ from traditional Nix packages, and how to enable and use them on your system.\nWhat Are Nix Flakes? Nix Flakes are a new feature in the Nix package manager that offer a more declarative and reproducible approach to package management and system configuration. They are designed to address some of the limitations of traditional Nix package management.\nDifferences Between Flakes and Traditional Nix Packages Nix Flakes differ from traditional Nix packages in several key ways:\nDeclarative Configuration: Flakes encourage a more declarative configuration style, making it easier to specify precisely what packages and system configurations you want.\nReproducibility: Flakes make it easier to create reproducible builds and system configurations, reducing the chances of unexpected changes.\nGit Integration: Flakes leverage Git for fetching dependencies, enabling more flexible and versioned package management.\nSimplified Channel Management: Flakes simplify channel management by allowing you to specify dependencies directly in your flake.nix file.\nEnabling Flakes on Your System To enable Nix Flakes system-wide on NixOS, follow these steps:\nOpen your configuration.nix file.\nAdd the following lines to enable the nix-command and flakes features:\n1 nix.settings.experimental-features = [ \u0026#34;nix-command\u0026#34; \u0026#34;flakes\u0026#34; ]; Since Flakes use Git to pull dependencies, ensure that Git is installed by adding it to your system packages: 1 environment.systemPackages = with pkgs; [ git ]; Apply the changes by running the following command: 1 sudo nixos-rebuild switch You have now successfully enabled nix flakes and the new nix command on your system.\nManaging System Channels Using Nix Flakes When flakes is enabled, it first look for a file called /etc/nixos/flake.nix. If not found, it will fallback to using /etc/nixos/configuration.nix.\nTo adapt your existing configuration for use with Flakes, you can use the following template. Be sure to adjust the system and architecture to match your setup:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { description = \u0026#34;My NixOS configuration\u0026#34;; inputs = { nixpkgs = { url = \u0026#34;github:nixos/nixpkgs/nixos-23.05\u0026#34;; }; }; outputs = inputs: { nixosConfigurations = { nixos = inputs.nixpkgs.lib.nixosSystem { system = \u0026#34;x86_64-linux\u0026#34;; specialArgs = { inherit inputs; }; modules = [ ./configuration.nix ]; }; }; }; } If you choose to manage your system using a flake.nix, you can remove your current channels by running:\n1 2 sudo nix-channel --list sudo nix-channel --remove nixos-23.05 Additionally, consider removing the home-manager channel if it has been added.\nHere\u0026rsquo;s an example of a configuration file that preserves your existing config and home-manager setup:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { description = \u0026#34;The flake configuration of my NixOS machine\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixos-23.05\u0026#34;; home-manager.url = \u0026#34;github:nix-community/home-manager/release-23.05\u0026#34;; home-manager.inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; outputs = inputs@{nixpkgs, home-manager, ...}: { nixosConfigurations = { nixos = nixpkgs.lib.nixosSystem { system = \u0026#34;x86_64-linux\u0026#34;; specialArgs = { inherit inputs; }; modules = [ ./configuration.nix ]; }; }; }; } With this configuration, you can effectively manage your system using Nix Flakes while preserving your previous setup.\nHow to enable autoUpgrade with flakes? Because flakes write a lock the old way of configuring autoUpgrade no longers works unless we pass some flags to it. To have autoUpgrade as before you could do the following:\n1 2 3 4 5 6 7 8 # Auto upgrade the system system.autoUpgrade = { enable = true; flake = inputs.self.outPath; flags = [ \u0026#34;--update-input\u0026#34; \u0026#34;nixpkgs\u0026#34; ]; persistent = true; dates = \u0026#34;daily\u0026#34;; }; Photo by Marc Newberry on Unsplash\n","date":"2023-09-28T00:00:00Z","image":"https://mikaelfangel.github.io/p/demystifying-nix-flakes-part1/cover_hu1440776929078511471.jpg","permalink":"https://mikaelfangel.github.io/p/demystifying-nix-flakes-part1/","title":"Demystifying Nix Flakes - Part 1"},{"content":"For a considerable time, I had aspired to become a package maintainer for a Linux distribution. Encouraged by my recent and positive encounters with NixOS and its community, I decided to take the plunge by maintaining a Nix package. In this post, I aim to share the valuable lessons I learned during my first package contribution. However, it\u0026rsquo;s essential to note that for a comprehensive set of guidelines, one should always refer to the CONTRIBUTING.md document. The content of this post may appear basic to some, and most of these insights are drawn from my experience with this Pull Request and the CONTRIBUTING.md guidelines.\nPackage Naming If the package you\u0026rsquo;re adding has a name that conflicts with an existing package in nixpkgs, endeavor to give your package a meaningful and distinct name. In my case, the package I attempted to add was named \u0026ldquo;slurm,\u0026rdquo; which had a naming conflict with an existing package. As suggested in my Pull Request, I ultimately named the package \u0026ldquo;slurm-nm\u0026rdquo; to clarify that it is a network monitoring tool.\nPlacement The package should be located within the new hierarchical structure, following the path pkgs/by-name/sl/slurm-cli/package.nix. There\u0026rsquo;s no longer a need to include it at the top-level for it to function correctly.\nBuild Once the package is correctly placed, build it from the root of the project using nix-build -A package-name, and then verify that the package located at result/bin/package functions as expected.\nContents Ensure that the package does not contain any trailing whitespace, and there should be at most one newline between statements. If the buildPhase and installPhase do not perform any actions, you can exclude them from the derivation file. Additionally, the meta section in the file should provide information about the license, maintainer, and, in this case, the main program for the derivation. During this process, I learned that license.gpl2 is deprecated in favor of license.gpl2Plus and license.gpl2Only.\nCommit Rules Adding Yourself as a Maintainer If you have never committed anything to nixpkgs before, you should add yourself as a maintainer to the maintainer-list.nix file following the structure below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 handle = { # Required name = \u0026#34;Your name\u0026#34;; # Optional, but at least one of email, matrix, or githubId must be given email = \u0026#34;address@example.org\u0026#34;; matrix = \u0026#34;@user:example.org\u0026#34;; github = \u0026#34;GithubUsername\u0026#34;; githubId = your-github-id; keys = [{ fingerprint = \u0026#34;AAAA BBBB CCCC DDDD EEEE FFFF 0000 1111 2222 3333\u0026#34;; }]; }; This addition to the maintainer-list must be in alphabetical order. The commit adding yourself to this list should adhere to the guidelines and, therefore, have a commit message like \u0026ldquo;maintainers: add mikaelfangel\u0026rdquo;. Importantly, this commit MUST precede a commit that adds the package. If the commit ordering is incorrect, use git rebase -i to reorder the commits. Once done, use git push --force-with-lease to push the changes.\nAdding the Package When adding the package, the commit message should follow the format \u0026ldquo;package-name: init at version\u0026rdquo;. For example, \u0026ldquo;slurm: init at 0.4.4\u0026rdquo;.\nPhoto by Yeshi Kangrang on Unsplash\n","date":"2023-09-26T00:00:00Z","image":"https://mikaelfangel.github.io/p/nixpkgs-first-timer/cover_hu4697244305109245532.jpg","permalink":"https://mikaelfangel.github.io/p/nixpkgs-first-timer/","title":"My Journey as a First-Time Nixpkgs Contributor"},{"content":"Here I\u0026rsquo;ll post the code for my solutions to the 4th chapter of the book. The solutions for the book is made by me as a part of the course \u0026ldquo;02157 Functional Programming\u0026rdquo; on DTU. I\u0026rsquo;ll update the post with more solutions when and if I solve more of the exercises.\n4.3 In this function we should generate the first n even numbers. I use tail recursion for speed and to avoid stackoverflow. Because we should generate the first n even numbers we always start the iterator from 0 and then we can just increment the iterator i with 2 each time. By incrementing by 2 each time we avoid a check for if the numbers are even or not.\n1 2 3 4 5 6 let evenN n = let rec evenNInner acc = function | i when i \u0026lt;= n -\u0026gt; evenNInner (i::acc) (i + 2) | _ -\u0026gt; List.rev acc evenNInner [] 0 4.7 We should find the number of times x occurs in a given list. To do this we split the list using the cons operator and then compare the head with the given x. Each time there is a match we add one to the result and continue the recursion. If there is no match we just recurse without adding anything. This effectively gives us the number of time x occurs in the list.\n1 2 3 4 let rec multiplicity x = function | [] -\u0026gt; 0 | head :: tail when x = head -\u0026gt; 1 + multiplicity x tail | _ :: tail -\u0026gt; multiplicity x tail 4.9 We should write a zip function and because a zip list is just a list of tuples containing the contents of both list we contruct this using a simple match pattern. We also throws an error if the list are of uneven lengths as it is thus not possible to zip the two lists.\n1 2 3 4 let rec zip = function | [], [] -\u0026gt; [] | x::xs, y::ys -\u0026gt; (x, y)::zip(xs, ys) | _ -\u0026gt; failwith \u0026#34;zip: The lists are of uneven lengths\u0026#34; 4.11 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let rec count (l, x) = match l with | [] -\u0026gt; 0 | l::ls when l = x -\u0026gt; 1 + count(ls, x) | _::ls -\u0026gt; count(ls, x) let rec insert (l, x) = match l with | [] -\u0026gt; [] | l::ls when x \u0026lt;= l -\u0026gt; x::ls | l::ls -\u0026gt; l::insert(ls, x) let rec intersect = function | [], _ | _, [] -\u0026gt; [] | x::xs, y::ys when x = y -\u0026gt; x :: intersect (xs, ys) | x::xs, y::ys when x \u0026lt; y -\u0026gt; intersect (xs, y::ys) | x::xs, _::ys -\u0026gt; intersect (x::xs, ys) let rec plus = function | [], ys -\u0026gt; ys | xs, [] -\u0026gt; xs | x::xs, y::ys when x \u0026lt;= y -\u0026gt; x :: plus (xs, y::ys) | xs, y::ys -\u0026gt; y :: plus (xs, ys) let rec minus = function | [], _ -\u0026gt; [] | xs, [] -\u0026gt; xs | x::xs, y::ys when x = y -\u0026gt; minus (xs, ys) | x::xs, y::ys when x \u0026lt; y -\u0026gt; x :: minus(xs, y::ys) | x::xs, _::ys -\u0026gt; minus(x::xs, ys) 4.12 Here we should sum up all elements where the predicate p is true. This we do by using a match pattern with a when statement. If the predicate is true we just recurse until the list is empty and then returning 0.\n1 2 3 4 5 let rec sum ((p:int -\u0026gt; bool), (xs)) = match xs with | [] -\u0026gt; 0 | x::xs when p(x) -\u0026gt; x + sum(p, xs) | _::xs -\u0026gt; sum(p, xs) 4.16 1 2 3 f: int * int List -\u0026gt; int List g: a\u0026#39; * a\u0026#39; List -\u0026gt; a\u0026#39; * a\u0026#39; List h: a\u0026#39; List -\u0026gt; a\u0026#39; List 4.17 1 (a\u0026#39; -\u0026gt; bool) -\u0026gt; a\u0026#39; List -\u0026gt; a\u0026#39; List 4.18 1 (a\u0026#39; -\u0026gt; a\u0026#39;) -\u0026gt; a\u0026#39; List -\u0026gt; a\u0026#39; List Book by Michael R. Hansen and Hans Richel\nPhoto by Ilija Boshkov on Unsplash\n","date":"2023-09-25T00:00:00Z","image":"https://mikaelfangel.github.io/p/function-programming-chap4/cover_hu1164555520794942236.jpg","permalink":"https://mikaelfangel.github.io/p/function-programming-chap4/","title":"Solutions to Functional Programming Using F# Chap. 4"},{"content":"Problem You are given a time period of n seconds, during which waves of robots arrive. Each wave consists of Xi robots, and you have an EMP that can be used to defeat them. The EMP has a charge, denoted by the function f(j), which recharges after use. The goal is to find the optimal times to activate the EMP to maximize the total number of robots defeated over the entire period n.\nInput The first line contains the value of n, representing the duration of the time period. The second line contains n integers, Xi, representing the number of robots in each wave. The third line contains n values representing the output of the function f(j) at each second. Output A single line containing the maximum number of robots defeated.\nSolution Approach To solve this problem, we can make some key observations:\nWe cannot defeat more robots than there are in a given wave or more robots than the EMP charge allows. The number of robots defeated in a wave is given by min(Xi, f(j)), where Xi is the number of robots in that wave, and f(j) is the EMP charge. The number of robots that can be defeated in the next iteration depends on min(Xi+1, f(1)), as the EMP charge resets at each iteration. We can express the problem using the following recurrence relation:\n1 OPT(i, j) = max(min(Xi, f(j)) + OPT(i + 1, 1), OPT(i + 1, j + 1)) Here, OPT(i, j) represents the maximum number of robots defeated starting from the i\u0026rsquo;th second with EMP charge j. This recursive relation helps us find the optimal strategy for using the EMP throughout the time period.\nPhoto by ANIRUDH on Unsplah\n","date":"2023-09-22T00:00:00Z","image":"https://mikaelfangel.github.io/p/defending-zion/cover_hu7927332361478710483.jpg","permalink":"https://mikaelfangel.github.io/p/defending-zion/","title":"Defending Zion"},{"content":"A palindrome is a non-empty string that exhibits symmetry when read forwards and backwards. Examples of palindromes include “anna,” “racecar,” and “abba.”\nProblem Determine the longest palindromic subsequence of a given string. To find the palindrome you are allowed to delete characters in the string.\nInput A string of length n\nOutput The length of the longest palindrome\nSolution Approach To address this problem, we leverage the Longest Common Subsequence (LCS) algorithm, a dynamic programming technique. This approach entails breaking the problem into smaller, more manageable subproblems.\nIn our context, the core issue revolves around deciding whether a character should be included in the longest palindromic subsequence or not. The hallmark of palindromes is their symmetric nature, reading the same forwards and backwards. To harness this property, we apply the LCS algorithm to both the original string and its reversed counterpart.\nThis systematic application of LCS facilitates the efficient identification of the longest palindromic subsequence within the given string.\nImplementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class LongestPalindrome { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String input = br.readLine(); int n = input.length(); int[][] matrix = new int[n + 1][n + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if(input.charAt(n - j) == input.charAt(i - 1)) { matrix[i][j] = matrix[i - 1][j - 1] + 1; } else { matrix[i][j] = Math.max(matrix[i - 1][j], matrix[i][j - 1]); } } } System.out.println(matrix[n][n]); } } ","date":"2023-09-20T00:00:00Z","permalink":"https://mikaelfangel.github.io/p/longest-palindrome/","title":"Longest Palindromic Subsequence"},{"content":"Welcome to my personal blog where I share my notes on stuff I find interesting. I\u0026rsquo;ve created this blog to share information I find and as a way of taking notes on tehcnical topics.\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2023-09-19T00:00:00Z","image":"https://mikaelfangel.github.io/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://mikaelfangel.github.io/p/hello-world/","title":"Hello World"}]